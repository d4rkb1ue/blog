<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>multithread on d4rkb1ue&#39;s Blog</title>
    <link>https://drkbl.com/tags/multithread/</link>
    <description>Recent content in multithread on d4rkb1ue&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Contact me at 7874364@gmail.com</copyright>
    <lastBuildDate>Sun, 19 Jul 2020 03:25:38 -0700</lastBuildDate>
    
	<atom:link href="https://drkbl.com/tags/multithread/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Socket Web Server With Multithread in Python</title>
      <link>https://drkbl.com/posts/socket-web-server-with-multithread-in-python/</link>
      <pubDate>Sun, 19 Jul 2020 03:25:38 -0700</pubDate>
      
      <guid>https://drkbl.com/posts/socket-web-server-with-multithread-in-python/</guid>
      <description>Socket in Unix/Linux  Socket in Unix/Linux is just file descriptor, which means you can just treat it as file. Socket exists on the both ends of the communicators as the endpoints. Socket can be full duplex. Since Socket are inherently file, then it has its own buffer for both Reading and Writing. The communication process is like,  Reading data from its reading buffer and write data to its writing buffer When the writing buffer is full(or call flush), the data will be passed to the peer&#39;s reading buffer Peer will refuse to be inputed when full    Socket Server/Client in Python  Server&#39;s serversocket.</description>
    </item>
    
  </channel>
</rss>